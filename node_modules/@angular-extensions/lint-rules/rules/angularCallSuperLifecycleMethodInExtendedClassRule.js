"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Lint = __importStar(require("tslint"));
var ts = __importStar(require("typescript"));
var tsutils = __importStar(require("tsutils"));
var tsquery_1 = require("@phenomnomnominal/tsquery");
var utils_1 = require("tslint/lib/utils");
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.componentLifeCycleMethods = [
            "ngOnDestroy",
            "ngOnInit",
            "ngAfterViewInit",
            "ngAfterContentInit",
            "ngOnChanges",
            "ngDoCheck",
            "ngAfterContentChecked",
            "ngAfterViewChecked"
        ];
        _this.directiveLifeCycleMethods = [
            "ngOnDestroy",
            "ngOnInit"
        ];
        return _this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        var _this = this;
        var failures = [];
        // find all classes with an @Component() decorator and heritage clause
        var componentClassDeclarations = tsquery_1.tsquery(sourceFile, "ClassDeclaration:has(Decorator[expression.expression.name='Component']):has(HeritageClause:has(ExpressionWithTypeArguments))");
        // find all classes with an @Directive() decorator and heritage clause
        var directiveClassDeclarations = tsquery_1.tsquery(sourceFile, "ClassDeclaration:has(Decorator[expression.expression.name='Directive']):has(HeritageClause:has(ExpressionWithTypeArguments))");
        // check all components
        __spreadArrays(componentClassDeclarations, componentClassDeclarations
            .map(function (classDeclaration) { return _this.findParentClasses(program, classDeclaration); })
            .reduce(function (allParentClasses, parentClasses) { return __spreadArrays(allParentClasses, parentClasses); }, [])).forEach(function (classDeclaration) {
            failures.push.apply(failures, _this.checkLifeCycleMethodSuperInvokation(classDeclaration.getSourceFile(), program, classDeclaration, false));
        });
        // check all directives
        __spreadArrays(directiveClassDeclarations, directiveClassDeclarations
            .map(function (classDeclaration) { return _this.findParentClasses(program, classDeclaration); })
            .reduce(function (allParentClasses, parentClasses) { return __spreadArrays(allParentClasses, parentClasses); }, [])).forEach(function (classDeclaration) {
            failures.push.apply(failures, _this.checkLifeCycleMethodSuperInvokation(classDeclaration.getSourceFile(), program, classDeclaration, true));
        });
        return failures;
    };
    /**
     * Verify that a class implementing a lifecycle method calls super.lifeCycleMethod() if it overrides any parent implementation of it
     */
    Rule.prototype.checkLifeCycleMethodSuperInvokation = function (sourceFile, program, classDeclaration, isDirective) {
        var _this = this;
        var lintFailures = [];
        var lifeCycleMethodsToCheck = isDirective ? this.directiveLifeCycleMethods : this.componentLifeCycleMethods;
        // check all life cycle methods
        lifeCycleMethodsToCheck.forEach(function (lifeCycleMethodName) {
            // find an implementation of the lifecycle method
            var lifeCycleMethod = _this.findLifeCycleMethod(classDeclaration, lifeCycleMethodName);
            // if implementation found, check parent implementations are called when overriding
            if (lifeCycleMethod) {
                var parentClasses = _this.findParentClasses(program, classDeclaration);
                if (parentClasses.some(function (parentClass) { return !!_this.findLifeCycleMethod(parentClass, lifeCycleMethodName); })) {
                    // some parent has life cycle method implementation, ensure super.lifeCycleMethod() is called
                    var superLifeCycleMethodCall = _this.findSuperLifeCycleMethodInvocation(lifeCycleMethod, lifeCycleMethodName);
                    if (!superLifeCycleMethodCall) {
                        lintFailures.push(new Lint.RuleFailure(sourceFile, lifeCycleMethod.name ? lifeCycleMethod.name.getStart() : sourceFile.getStart(), lifeCycleMethod.name ? lifeCycleMethod.name.getStart() +
                            lifeCycleMethod.name.getWidth() : sourceFile.getStart() + sourceFile.getWidth(), Rule.FAILURE_STRING.replace("{methodName}", lifeCycleMethod.name.getText()), _this.ruleName));
                    }
                }
            }
        });
        return lintFailures;
    };
    /**
     * Returns the method declaration of the life cycle method implemenation in the class given
     */
    Rule.prototype.findLifeCycleMethod = function (classDeclaration, lifeCycleMethodName) {
        return classDeclaration.members.find(function (member) { return member.name && member.name.getText() === lifeCycleMethodName; });
    };
    /**
     * Returns the property access expression of the invocation of super.lifeCycleMethod(), if any
     */
    Rule.prototype.findSuperLifeCycleMethodInvocation = function (methodDeclaration, lifeCycleMethodName) {
        if (!methodDeclaration.body) {
            return undefined;
        }
        var propertyAccessExpressions = tsquery_1.tsquery(methodDeclaration, "CallExpression > PropertyAccessExpression[expression.kind=" + ts.SyntaxKind.SuperKeyword + "][name.text=\"" + lifeCycleMethodName + "\"]");
        if (propertyAccessExpressions && propertyAccessExpressions.length > 0) {
            return propertyAccessExpressions[0];
        }
    };
    /**
     * recursively find all parent classes of the class given
     */
    Rule.prototype.findParentClasses = function (program, classDeclarationToBeChecked) {
        var _this = this;
        var classDeclarationsFound = [];
        var typeChecker = program.getTypeChecker();
        var heritageClauses = classDeclarationToBeChecked.heritageClauses;
        if (!heritageClauses) {
            return [];
        }
        heritageClauses.forEach(function (heritageClause) {
            if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
                heritageClause.types.forEach(function (heritageClauseType) {
                    if (!tsutils.isIdentifier(heritageClauseType.expression)) {
                        return;
                    }
                    var extendType = typeChecker.getTypeAtLocation(heritageClauseType.expression);
                    if (extendType && extendType.symbol
                        && extendType.symbol.declarations
                        && extendType.symbol.declarations.length > 0
                        && tsutils.isClassDeclaration(extendType.symbol.declarations[0])) {
                        var parentClassDeclaration = extendType.symbol.declarations[0];
                        classDeclarationsFound.push(parentClassDeclaration);
                        classDeclarationsFound.push.apply(classDeclarationsFound, _this.findParentClasses(program, parentClassDeclaration));
                    }
                });
            }
        });
        return classDeclarationsFound;
    };
    ;
    Rule.FAILURE_STRING = 'call to super.{methodName}() is missing';
    Rule.metadata = {
        description: utils_1.dedent(templateObject_1 || (templateObject_1 = __makeTemplateObject(["Enforces the application to call parent lifecycle function e.g. super.ngOnDestroy()\n                        when using inheritance within an Angular component or directive."], ["Enforces the application to call parent lifecycle function e.g. super.ngOnDestroy()\n                        when using inheritance within an Angular component or directive."]))),
        options: null,
        optionsDescription: "",
        requiresTypeInfo: true,
        ruleName: "angular-call-super-lifecycle-method-in-extended-class",
        type: "functionality",
        typescriptOnly: true
    };
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
var templateObject_1;
