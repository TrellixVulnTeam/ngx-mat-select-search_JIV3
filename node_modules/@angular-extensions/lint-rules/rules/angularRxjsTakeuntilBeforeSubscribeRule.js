"use strict";
/**
 * @license Use of this source code is governed by an MIT-style license that
 * can be found in the LICENSE file at https://github.com/cartant/rxjs-tslint-rules
 */
/*tslint:disable:no-use-before-declare*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Lint = __importStar(require("tslint"));
var tsutils = __importStar(require("tsutils"));
var ts = __importStar(require("typescript"));
var tsutils_etc_1 = require("tsutils-etc");
var tsquery_1 = require("@phenomnomnominal/tsquery");
var utils_1 = require("tslint/lib/utils");
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.operatorsRequiringPrecedingTakeuntil = [
            "shareReplay"
        ];
        _this.ignoreOperatorsWithRefCountTrue = [
            "shareReplay"
        ];
        return _this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        var _this = this;
        var failures = [];
        // find all classes with an @Component() decorator
        var componentClassDeclarations = tsquery_1.tsquery(sourceFile, "ClassDeclaration:has(Decorator[expression.expression.name='Component'])");
        // find all classes with an @Directive() decorator
        var directiveClassDeclarations = tsquery_1.tsquery(sourceFile, "ClassDeclaration:has(Decorator[expression.expression.name='Directive'])");
        __spreadArrays(componentClassDeclarations, directiveClassDeclarations, componentClassDeclarations.map(function (classDeclaration) { return _this.findParentClasses(program, classDeclaration); })
            .reduce(function (classDeclarations, parentClassDeclaration) { return __spreadArrays(classDeclarations, parentClassDeclaration); }, []), directiveClassDeclarations.map(function (classDeclaration) { return _this.findParentClasses(program, classDeclaration); })
            .reduce(function (classDeclarations, parentClassDeclaration) { return __spreadArrays(classDeclarations, parentClassDeclaration); }, [])).forEach(function (componentClassDeclaration) {
            failures.push.apply(failures, _this.checkComponentClassDeclaration(componentClassDeclaration.getSourceFile(), program, componentClassDeclaration));
        });
        return failures;
    };
    /**
     * recursively find all parent classes of the classe given
     */
    Rule.prototype.findParentClasses = function (program, classDeclarationToBeChecked) {
        var _this = this;
        var classDeclarationsFound = [];
        var typeChecker = program.getTypeChecker();
        var heritageClauses = classDeclarationToBeChecked.heritageClauses;
        if (!heritageClauses) {
            return [];
        }
        heritageClauses.forEach(function (heritageClause) {
            if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
                heritageClause.types.forEach(function (heritageClauseType) {
                    if (!tsutils.isIdentifier(heritageClauseType.expression)) {
                        return;
                    }
                    var extendType = typeChecker.getTypeAtLocation(heritageClauseType.expression);
                    if (extendType && extendType.symbol
                        && extendType.symbol.declarations
                        && extendType.symbol.declarations.length > 0
                        && tsutils.isClassDeclaration(extendType.symbol.declarations[0])) {
                        var parentClassDeclaration = extendType.symbol.declarations[0];
                        classDeclarationsFound.push(parentClassDeclaration);
                        classDeclarationsFound.push.apply(classDeclarationsFound, _this.findParentClasses(program, parentClassDeclaration));
                    }
                });
            }
        });
        return classDeclarationsFound;
    };
    ;
    /**
     * Checks a component class for occurrences of .subscribe() and corresponding takeUntil() requirements
     */
    Rule.prototype.checkComponentClassDeclaration = function (sourceFile, program, componentClassDeclaration) {
        var _this = this;
        var failures = [];
        var typeChecker = program.getTypeChecker();
        /** list of destroy subjects used in takeUntil() operators */
        var destroySubjectNamesUsed = {};
        // find observable.subscribe() call expressions
        var subscribePropertyAccessExpressions = tsquery_1.tsquery(componentClassDeclaration, "CallExpression > PropertyAccessExpression[name.name=\"subscribe\"]");
        // check whether it is an observable and check the takeUntil before the subscribe
        subscribePropertyAccessExpressions.forEach(function (node) {
            var propertyAccessExpression = node;
            var type = typeChecker.getTypeAtLocation(propertyAccessExpression.expression);
            if (tsutils_etc_1.couldBeType(type, "Observable")) {
                var subscribeFailures = _this.checkTakeuntilBeforeSubscribe(sourceFile, propertyAccessExpression);
                failures.push.apply(failures, subscribeFailures.failures);
                if (subscribeFailures.destroySubjectName) {
                    destroySubjectNamesUsed[subscribeFailures.destroySubjectName] = true;
                }
            }
        });
        // find observable.pipe() call expressions
        var pipePropertyAccessExpressions = tsquery_1.tsquery(componentClassDeclaration, "CallExpression > PropertyAccessExpression[name.name=\"pipe\"]");
        // check whether it is an observable and check the takeUntil before operators requiring it
        pipePropertyAccessExpressions.forEach(function (node) {
            var propertyAccessExpression = node;
            var pipeCallExpression = node.parent;
            var type = typeChecker.getTypeAtLocation(propertyAccessExpression.expression);
            if (tsutils_etc_1.couldBeType(type, "Observable")) {
                var pipeFailures = _this.checkTakeuntilBeforeOperatorsInPipe(sourceFile, pipeCallExpression.arguments);
                failures.push.apply(failures, pipeFailures.failures);
                pipeFailures.destroySubjectNames.forEach(function (destroySubjectName) {
                    if (destroySubjectName) {
                        destroySubjectNamesUsed[destroySubjectName] = true;
                    }
                });
            }
        });
        // check the ngOnDestroyMethod
        var destroySubjectNamesUsedList = Object.keys(destroySubjectNamesUsed);
        destroySubjectNamesUsedList.forEach(function (destroySubjectNameUsed) {
            // look for ngOnDestroy in class and in all parent classes
            var classesToCheck = __spreadArrays([
                componentClassDeclaration
            ], _this.findParentClasses(program, componentClassDeclaration));
            var ngOnDestroyFailuresList = classesToCheck.map(function (classDeclaration) { return _this.checkNgOnDestroy(sourceFile, classDeclaration, destroySubjectNameUsed); });
            // if there is no correct implementation of ngOnDestroy in any of the classes to be checked
            if (ngOnDestroyFailuresList.length > 0 && !ngOnDestroyFailuresList.find(function (failures) { return failures.length === 0; })) {
                failures.push.apply(failures, ngOnDestroyFailuresList[0]);
            }
        });
        return failures;
    };
    /**
     * Checks whether a .subscribe() is preceded by a .pipe(<...>, takeUntil(<...>))
     */
    Rule.prototype.checkTakeuntilBeforeSubscribe = function (sourceFile, node) {
        var failures = [];
        var subscribeContext = node.expression;
        /** Whether a takeUntil() operator preceding the .subscribe() was found */
        var lastTakeUntilFound = false;
        /** name of the takeUntil() argument */
        var destroySubjectName;
        // check whether subscribeContext.expression is <something>.pipe()
        if (tsutils.isCallExpression(subscribeContext) &&
            tsutils.isPropertyAccessExpression(subscribeContext.expression) &&
            subscribeContext.expression.name.getText() === "pipe") {
            var pipedOperators = subscribeContext.arguments;
            if (pipedOperators.length > 0) {
                var lastPipedOperator = pipedOperators[pipedOperators.length - 1];
                // check whether the last operator in the .pipe() call is takeUntil()
                if (tsutils.isCallExpression(lastPipedOperator)) {
                    var lastPipedOperatorFailures = this.checkTakeuntilOperator(sourceFile, lastPipedOperator);
                    if (lastPipedOperatorFailures.isTakeUntil) {
                        lastTakeUntilFound = true;
                        destroySubjectName = lastPipedOperatorFailures.destroySubjectName;
                        failures.push.apply(failures, lastPipedOperatorFailures.failures);
                    }
                }
            }
        }
        // add failure if there is no takeUntil() in the last position of a .pipe()
        if (!lastTakeUntilFound) {
            failures.push(new Lint.RuleFailure(sourceFile, node.name.getStart(), node.name.getStart() + node.name.getWidth(), Rule.FAILURE_STRING, this.ruleName));
        }
        return { failures: failures, destroySubjectName: destroySubjectName };
    };
    /**
     * Checks whether there is a takeUntil() operator before operators like shareReplay()
     */
    Rule.prototype.checkTakeuntilBeforeOperatorsInPipe = function (sourceFile, pipeArguments) {
        var _this = this;
        var failures = [];
        var destroySubjectNames = [];
        // go though all pipe arguments, i.e. rxjs operators
        pipeArguments.forEach(function (pipeArgument, i) {
            // check whether the operator requires a preceding takeuntil
            if (tsutils.isCallExpression(pipeArgument) &&
                tsutils.isIdentifier(pipeArgument.expression) &&
                _this.operatorsRequiringPrecedingTakeuntil.includes(pipeArgument.expression.getText())
                && !_this.isSafeRefCountOperator(pipeArgument)) {
                var precedingTakeUntilOperatorFound = false;
                // check the preceding operator to be takeuntil
                if (i > 0 &&
                    pipeArguments[i - 1] &&
                    tsutils.isCallExpression(pipeArguments[i - 1])) {
                    var precedingOperator = pipeArguments[i - 1];
                    var precedingOperatorFailures = _this.checkTakeuntilOperator(sourceFile, precedingOperator);
                    if (precedingOperatorFailures.isTakeUntil) {
                        precedingTakeUntilOperatorFound = true;
                        failures.push.apply(failures, precedingOperatorFailures.failures);
                        if (precedingOperatorFailures.destroySubjectName) {
                            destroySubjectNames.push(precedingOperatorFailures.destroySubjectName);
                        }
                    }
                }
                if (!precedingTakeUntilOperatorFound) {
                    failures.push(new Lint.RuleFailure(sourceFile, pipeArgument.getStart(), pipeArgument.getStart() + pipeArgument.getWidth(), Rule.FAILURE_STRING_OPERATOR.replace("{operator}", pipeArgument.expression.getText()), _this.ruleName));
                }
            }
        });
        return { failures: failures, destroySubjectNames: destroySubjectNames };
    };
    /**
     * Checks whether the operator given is takeUntil and uses an allowed destroy subject name
     */
    Rule.prototype.checkTakeuntilOperator = function (sourceFile, operator) {
        var failures = [];
        var destroySubjectName;
        var isTakeUntil = false;
        if (tsutils.isIdentifier(operator.expression) &&
            operator.expression.text === "takeUntil") {
            isTakeUntil = true;
            // check the argument of takeUntil()
            var destroySubjectNameCheck = this.checkDestroySubjectName(sourceFile, operator);
            failures.push.apply(failures, destroySubjectNameCheck.failures);
            destroySubjectName = destroySubjectNameCheck.destroySubjectName;
        }
        return { failures: failures, destroySubjectName: destroySubjectName, isTakeUntil: isTakeUntil };
    };
    /**
     * Checks whether the argument of the given takeUntil(this.destroy$) expression
     * is a property of the class
     */
    Rule.prototype.checkDestroySubjectName = function (sourceFile, takeUntilOperator) {
        var failures = [];
        /** name of the takeUntil() argument */
        var destroySubjectName;
        /** whether the takeUntil() argument is among the allowed names */
        var isAllowedDestroySubject = false;
        var takeUntilOperatorArgument;
        var highlightedNode = takeUntilOperator;
        // check the takeUntil() argument
        if (takeUntilOperator.arguments.length >= 1 &&
            takeUntilOperator.arguments[0]) {
            highlightedNode = takeUntilOperator.arguments[0];
            if (tsutils.isPropertyAccessExpression(takeUntilOperator.arguments[0])) {
                takeUntilOperatorArgument = takeUntilOperator
                    .arguments[0];
                destroySubjectName = takeUntilOperatorArgument.name.getText();
                isAllowedDestroySubject = true;
            }
        }
        if (!isAllowedDestroySubject) {
            failures.push(new Lint.RuleFailure(sourceFile, highlightedNode.getStart(), highlightedNode.getStart() + highlightedNode.getWidth(), Rule.FAILURE_STRING_SUBJECT_NAME, this.ruleName));
        }
        return { failures: failures, destroySubjectName: destroySubjectName };
    };
    /**
     * Checks whether the class implements an ngOnDestroy method and invokes .next() on the destroy subjects
     */
    Rule.prototype.checkNgOnDestroy = function (sourceFile, classDeclaration, destroySubjectNameUsed) {
        var failures = [];
        var ngOnDestroyMethod = classDeclaration.members.find(function (member) { return member.name && member.name.getText() === "ngOnDestroy"; });
        // check whether the ngOnDestroy method is implemented
        // and contains invocations of .next() on all destroy subjects used
        if (ngOnDestroyMethod) {
            failures.push.apply(failures, this.checkDestroySubjectMethodInvocation(sourceFile, ngOnDestroyMethod, destroySubjectNameUsed, "next"));
        }
        else {
            failures.push(new Lint.RuleFailure(sourceFile, classDeclaration.name ? classDeclaration.name.getStart() : sourceFile.getStart(), classDeclaration.name ? classDeclaration.name.getStart() + classDeclaration.name.getWidth() : sourceFile.getStart() + sourceFile.getWidth(), Rule.FAILURE_STRING_NG_ON_DESTROY, this.ruleName));
        }
        return failures;
    };
    /**
     * Checks whether <destroySubjectName>.<methodName>() is invoked in the ngOnDestroyMethod
     */
    Rule.prototype.checkDestroySubjectMethodInvocation = function (sourceFile, ngOnDestroyMethod, destroySubjectName, methodName) {
        var failures = [];
        var destroySubjectMethodInvocations = tsquery_1.tsquery(ngOnDestroyMethod, "CallExpression > PropertyAccessExpression[name.name=\"" + methodName + "\"]");
        // check whether there is an invocation of <destroySubjectName>.<methodName>()
        if (!destroySubjectMethodInvocations.some(function (nextInvocation) {
            return tsutils.isPropertyAccessExpression(nextInvocation.expression) &&
                nextInvocation.expression.name.getText() === destroySubjectName;
        })) {
            failures.push(new Lint.RuleFailure(sourceFile, ngOnDestroyMethod.name ? ngOnDestroyMethod.name.getStart() : sourceFile.getStart(), ngOnDestroyMethod.name ? ngOnDestroyMethod.name.getStart() +
                ngOnDestroyMethod.name.getWidth() : sourceFile.getStart() + sourceFile.getWidth(), Rule.FAILURE_STRING_NG_ON_DESTROY_SUBJECT_METHOD_NOT_CALLED.replace("{destroySubjectName}", "this." + destroySubjectName).replace("{methodName}", methodName), this.ruleName));
        }
        return failures;
    };
    /**
     * Returns whether the operator is whitelisted and uses refCount: true
     * e.g. shareReplay({bufferSize: 1, refCount: true})
     */
    Rule.prototype.isSafeRefCountOperator = function (operator) {
        return tsutils.isIdentifier(operator.expression)
            && this.ignoreOperatorsWithRefCountTrue.includes(operator.expression.text)
            && operator.arguments.length > 0
            && tsutils.isObjectLiteralExpression(operator.arguments[0])
            && operator.arguments[0].properties
                .some(function (property) { return tsutils.isPropertyAssignment(property)
                && property.name.getText() === 'refCount'
                && property.initializer.kind === ts.SyntaxKind.TrueKeyword; });
    };
    Rule.metadata = {
        description: utils_1.dedent(templateObject_1 || (templateObject_1 = __makeTemplateObject(["Enforces the application of the takeUntil operator\n                        when calling of subscribe within an Angular component or directive."], ["Enforces the application of the takeUntil operator\n                        when calling of subscribe within an Angular component or directive."]))),
        options: null,
        optionsDescription: "",
        requiresTypeInfo: true,
        ruleName: "angular-rxjs-takeuntil-before-subscribe",
        type: "functionality",
        typescriptOnly: true
    };
    Rule.FAILURE_STRING = "subscribe within a component must be preceded by takeUntil";
    Rule.FAILURE_STRING_SUBJECT_NAME = "takeUntil argument must be a property of the class, e.g. takeUntil(this.destroy$)";
    Rule.FAILURE_STRING_OPERATOR = "the {operator} operator used within a component must be preceded by takeUntil";
    Rule.FAILURE_STRING_NG_ON_DESTROY = "component containing subscribe must implement the ngOnDestroy() method";
    Rule.FAILURE_STRING_NG_ON_DESTROY_SUBJECT_METHOD_NOT_CALLED = "there must be an invocation of {destroySubjectName}.{methodName}() in ngOnDestroy()";
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
var templateObject_1;
